
@Mod(MEWVFForge.MODID)
public class MEWVFForge {
    public static final String MODID = "mewvf";
    public static final String VERSION = "0.9.2";
    public static final String MC_VERSION = "1.20.1";
    public static final String WEBVIEW_VERSION = "120.0.6099.129"; // Latest stable WebView
    
    private static volatile MEWVFForge instance;
    private static volatile boolean initialized = false;
    private static final Logger LOGGER = LogUtils.getLogger();
    private static PlatformType detectedPlatform;
    
    private static final Object INITIALIZATION_LOCK = new Object();
    
    public MEWVFForge() {
        instance = this;
        
        // Early platform detection
        detectedPlatform = PlatformDetector.detectPlatform();
        LOGGER.info("MEWVF v{} detected platform: {}", VERSION, detectedPlatform);
        
        // Register to mod event bus with error handling
        IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();
        modEventBus.addListener(this::onClientSetup);
        modEventBus.addListener(this::onCommonSetup);
        
        // Register to Forge event bus
        MinecraftForge.EVENT_BUS.register(this);
        MinecraftForge.EVENT_BUS.register(new ForgeEventHandler());
        
        LOGGER.info("MEWVF v{} loading for MC {} with WebView {}", VERSION, MC_VERSION, WEBVIEW_VERSION);
    }
    
    private void onCommonSetup(final FMLCommonSetupEvent event) {
        LOGGER.info("MEWVF common setup for platform: {}", detectedPlatform);
    }
    
    private void onClientSetup(final FMLClientSetupEvent event) {
        event.enqueueWork(() -> {
            try {
                LOGGER.info("Initializing MEWVF WebView framework for {}...", detectedPlatform);
                initializeWebViewFramework();
            } catch (Exception e) {
                LOGGER.error("Failed to initialize MEWVF during client setup", e);
            }
        });
    }
    
    private static synchronized void initializeWebViewFramework() {
        if (initialized) {
            LOGGER.warn("MEWVF already initialized, skipping...");
            return;
        }
        
        synchronized (INITIALIZATION_LOCK) {
            if (initialized) return;
            
            try {
                // Platform compatibility check
                if (!detectedPlatform.isSupported()) {
                    LOGGER.error("MEWVF unsupported on platform: {} ({})", 
                        detectedPlatform, System.getProperty("os.arch"));
                    displayUnsupportedPlatformMessage();
                    return;
                }
                
                // Initialize core systems
                UniversalWebViewManager.initialize(detectedPlatform);
                MEWVFRegistry.initialize();
                
                // Register shutdown hook
                Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                    try {
                        cleanup();
                    } catch (Exception e) {
                        LOGGER.error("Error in shutdown hook", e);
                    }
                }));
                
                initialized = true;
                LOGGER.info("MEWVF v{} initialized successfully for {}!", VERSION, detectedPlatform);
                displaySuccessMessage();
                
            } catch (Exception e) {
                LOGGER.error("MEWVF initialization failed on {}", detectedPlatform, e);
                displayErrorMessage(e.getMessage());
                throw new RuntimeException("MEWVF initialization failed", e);
            }
        }
    }
    
    private static void displayUnsupportedPlatformMessage() {
        String os = System.getProperty("os.name");
        String arch = System.getProperty("os.arch");
        
        LOGGER.info("=== MEWVF Platform Support ===");
        LOGGER.info("Current: {} on {}", os, arch);
        LOGGER.info("Supported: Android ARM64, Apple Silicon, Windows ARM64, Linux ARM64");
        LOGGER.info("For x86_64 systems, use original MCEF instead");
        LOGGER.info("===============================");
    }
    
    private static void displaySuccessMessage() {
        LOGGER.info("=== MEWVF Ready ===");
        LOGGER.info("Platform: {} (supported)", detectedPlatform);
        LOGGER.info("WebView: {} (latest)", WEBVIEW_VERSION);
        LOGGER.info("Framework ready for web browsing in Minecraft");
        LOGGER.info("===================");
    }
    
    private static void displayErrorMessage(String error) {
        LOGGER.error("=== MEWVF Initialization Failed ===");
        LOGGER.error("Platform: {}", detectedPlatform);
        LOGGER.error("Error: {}", error);
        LOGGER.error("Check device WebView support");
        LOGGER.error("===================================");
    }
    
    private static synchronized void cleanup() {
        if (!initialized) return;
        
        synchronized (INITIALIZATION_LOCK) {
            if (!initialized) return;
            
            try {
                LOGGER.info("MEWVF cleanup starting...");
                UniversalWebViewManager.cleanup();
                MEWVFRegistry.cleanup();
                initialized = false;
                LOGGER.info("MEWVF cleanup completed");
            } catch (Exception e) {
                LOGGER.error("Error during cleanup", e);
                initialized = false;
            }
        }
    }
    
    // Public API with validation
    public static synchronized MEWVFBrowser createBrowser(String id, int width, int height) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Browser ID cannot be null or empty");
        }
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Invalid dimensions: " + width + "x" + height);
        }
        if (!initialized) {
            throw new IllegalStateException("MEWVF not initialized on platform: " + detectedPlatform);
        }
        
        return UniversalWebViewManager.createBrowser(id.trim(), width, height);
    }
    
    public static MEWVFBrowser getBrowser(String id) {
        if (id == null || id.trim().isEmpty()) return null;
        return UniversalWebViewManager.getBrowser(id.trim());
    }
    
    public static synchronized void destroyBrowser(String id) {
        if (id == null || id.trim().isEmpty()) {
            LOGGER.warn("Attempted to destroy browser with null/empty ID");
            return;
        }
        UniversalWebViewManager.destroyBrowser(id.trim());
    }
    
    // Getters
    public static boolean isInitialized() { return initialized; }
    public static PlatformType getPlatform() { return detectedPlatform; }
    public static String getWebViewVersion() { return WEBVIEW_VERSION; }
    
    public static MEWVFForge getInstance() {
        if (instance == null) {
            throw new IllegalStateException("MEWVF instance not initialized");
        }
        return instance;
    }
    
    public static Logger getLogger() { return LOGGER; }
}

// Enhanced Platform Detection
public enum PlatformType {
    ANDROID_ARM64("Android ARM64", true, "Android devices with ARM64"),
    MACOS_APPLE_SILICON("macOS Apple Silicon", true, "M1/M2/M3/M4 Macs"),
    WINDOWS_ARM64("Windows ARM64", true, "ARM64 Windows PCs"),
    LINUX_ARM64("Linux ARM64", true, "ARM64 Linux systems"),
    
    WINDOWS_X64("Windows x86_64", false, "Intel/AMD Windows"),
    MACOS_INTEL("macOS Intel", false, "Intel Macs"), 
    LINUX_X64("Linux x86_64", false, "Intel/AMD Linux"),
    UNKNOWN("Unknown", false, "Unrecognized platform");
    
    private final String displayName;
    private final boolean supported;
    private final String description;
    
    PlatformType(String displayName, boolean supported, String description) {
        this.displayName = displayName;
        this.supported = supported;
        this.description = description;
    }
    
    public String getDisplayName() { return displayName; }
    public boolean isSupported() { return supported; }
    public String getDescription() { return description; }
    
    @Override
    public String toString() {
        return displayName + (supported ? " (supported)" : " (unsupported)");
    }
}

// Advanced Platform Detector
public class PlatformDetector {
    private static final Logger LOGGER = LogUtils.getLogger();
    
    public static PlatformType detectPlatform() {
        String os = System.getProperty("os.name", "").toLowerCase();
        String arch = System.getProperty("os.arch", "").toLowerCase();
        String version = System.getProperty("os.version", "");
        
        LOGGER.info("Platform Detection:");
        LOGGER.info("  OS: {}", os);
        LOGGER.info("  Architecture: {}", arch);
        LOGGER.info("  Version: {}", version);
        LOGGER.info("  Java: {}", System.getProperty("java.version"));
        
        // Android detection
        if (isAndroid(os, arch)) {
            return PlatformType.ANDROID_ARM64;
        }
        
        // macOS detection
        if (os.contains("mac")) {
            return isAppleSilicon(arch) ? PlatformType.MACOS_APPLE_SILICON : PlatformType.MACOS_INTEL;
        }
        
        // Windows detection
        if (os.contains("windows")) {
            return isARM64(arch) ? PlatformType.WINDOWS_ARM64 : PlatformType.WINDOWS_X64;
        }
        
        // Linux detection
        if (os.contains("linux")) {
            return isARM64(arch) ? PlatformType.LINUX_ARM64 : PlatformType.LINUX_X64;
        }
        
        return PlatformType.UNKNOWN;
    }
    
    private static boolean isAndroid(String os, String arch) {
        return os.contains("android") || 
               System.getProperty("java.vendor", "").toLowerCase().contains("android") ||
               System.getProperty("java.vm.vendor", "").toLowerCase().contains("android") ||
               (os.contains("linux") && hasAndroidClasses());
    }
    
    private static boolean hasAndroidClasses() {
        try {
            Class.forName("android.os.Build");
            return true;
        } catch (ClassNotFoundException e) {
            String vmName = System.getProperty("java.vm.name", "").toLowerCase();
            return vmName.contains("dalvik") || vmName.contains("art");
        }
    }
    
    private static boolean isAppleSilicon(String arch) {
        return arch.contains("aarch64") || arch.contains("arm64") || isRunningOnAppleSilicon();
    }
    
    private static boolean isRunningOnAppleSilicon() {
        try {
            ProcessBuilder pb = new ProcessBuilder("sysctl", "-n", "machdep.cpu.brand_string");
            Process process = pb.start();
            
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                String cpuInfo = reader.readLine();
                boolean completed = process.waitFor(5, TimeUnit.SECONDS);
                
                if (!completed) {
                    process.destroyForcibly();
                    return false;
                }
                
                return process.exitValue() == 0 && cpuInfo != null && 
                       cpuInfo.toLowerCase().contains("apple");
            }
        } catch (Exception e) {
            LOGGER.debug("Apple Silicon detection failed: {}", e.getMessage());
            return false;
        }
    }
    
    private static boolean isARM64(String arch) {
        return arch.contains("aarch64") || arch.contains("arm64") || 
               (arch.contains("arm") && arch.contains("64"));
    }
}

// Universal WebView Manager
public class UniversalWebViewManager {
    private static volatile PlatformType platform;
    private static WebViewProvider provider;
    private static final ConcurrentHashMap<String, MEWVFBrowser> browsers = new ConcurrentHashMap<>();
    private static ExecutorService executor;
    private static volatile boolean initialized = false;
    private static final Logger LOGGER = LogUtils.getLogger();
    
    private static final Object MANAGER_LOCK = new Object();
    
    public static void initialize(PlatformType platformType) {
        if (initialized) return;
        
        synchronized (MANAGER_LOCK) {
            if (initialized) return;
            
            platform = platformType;
            
            try {
                // Create managed thread pool
                executor = Executors.newFixedThreadPool(4, r -> {
                    Thread t = new Thread(r, "MEWVF-" + platformType.name());
                    t.setDaemon(true);
                    t.setUncaughtExceptionHandler((thread, ex) -> 
                        LOGGER.error("Uncaught exception in {}", thread.getName(), ex));
                    return t;
                });
                
                // Initialize platform provider
                provider = createProvider(platformType);
                provider.initialize();
                
                initialized = true;
                LOGGER.info("WebView manager initialized for {}", platformType);
                
            } catch (Exception e) {
                LOGGER.error("WebView manager initialization failed for {}", platformType, e);
                throw new RuntimeException("WebView manager init failed", e);
            }
        }
    }
    
    private static WebViewProvider createProvider(PlatformType platformType) {
        switch (platformType) {
            case ANDROID_ARM64: return new AndroidWebViewProvider();
            case MACOS_APPLE_SILICON: return new MacOSWebViewProvider();
            case WINDOWS_ARM64: return new WindowsWebViewProvider();
            case LINUX_ARM64: return new LinuxWebViewProvider();
            default: throw new UnsupportedOperationException("Unsupported: " + platformType);
        }
    }
    
    public static MEWVFBrowser createBrowser(String id, int width, int height) {
        if (!initialized) {
            throw new IllegalStateException("WebView manager not initialized");
        }
        
        if (browsers.containsKey(id)) {
            LOGGER.warn("Browser {} already exists, returning existing", id);
            return browsers.get(id);
        }
        
        try {
            MEWVFBrowser browser = provider.createBrowser(id, width, height);
            MEWVFBrowser existing = browsers.putIfAbsent(id, browser);
            
            if (existing != null) {
                try {
                    browser.destroy();
                } catch (Exception e) {
                    LOGGER.warn("Error cleaning up duplicate browser", e);
                }
                return existing;
            }
            
            LOGGER.info("Created {} browser: {} ({}x{})", platform, id, width, height);
            return browser;
            
        } catch (Exception e) {
            LOGGER.error("Browser creation failed on {}: {}", platform, id, e);
            throw new RuntimeException("Browser creation failed", e);
        }
    }
    
    public static MEWVFBrowser getBrowser(String id) {
        return browsers.get(id);
    }
    
    public static void destroyBrowser(String id) {
        MEWVFBrowser browser = browsers.remove(id);
        if (browser != null) {
            try {
                browser.destroy();
                LOGGER.info("Destroyed browser: {}", id);
            } catch (Exception e) {
                LOGGER.error("Error destroying browser: {}", id, e);
            }
        }
    }
    
    public static void tickAllBrowsers() {
        if (!initialized || executor.isShutdown()) return;
        
        CompletableFuture.runAsync(() -> {
            browsers.values().parallelStream().forEach(browser -> {
                try {
                    browser.tick();
                } catch (Exception e) {
                    LOGGER.error("Error ticking browser: {}", browser.getId(), e);
                }
            });
        }, executor).exceptionally(throwable -> {
            LOGGER.error("Error in browser tick task", throwable);
            return null;
        });
    }
    
    public static void updateAllTextures() {
        if (!initialized || executor.isShutdown()) return;
        
        CompletableFuture.runAsync(() -> {
            browsers.values().parallelStream().forEach(browser -> {
                try {
                    browser.updateTexture();
                } catch (Exception e) {
                    LOGGER.error("Error updating texture: {}", browser.getId(), e);
                }
            });
        }, executor).exceptionally(throwable -> {
            LOGGER.error("Error in texture update task", throwable);
            return null;
        });
    }
    
    public static Map<String, MEWVFBrowser> getBrowsers() {
        return Collections.unmodifiableMap(new HashMap<>(browsers));
    }
    
    public static void cleanup() {
        if (!initialized) return;
        
        synchronized (MANAGER_LOCK) {
            if (!initialized) return;
            
            LOGGER.info("Cleaning up {} browsers on {}...", browsers.size(), platform);
            
            // Destroy browsers with timeout per browser
            browsers.keySet().parallelStream().forEach(id -> {
                try {
                    destroyBrowser(id);
                } catch (Exception e) {
                    LOGGER.error("Error destroying browser during cleanup: {}", id, e);
                }
            });
            
            // Cleanup provider
            if (provider != null) {
                try {
                    provider.cleanup();
                } catch (Exception e) {
                    LOGGER.error("Provider cleanup error", e);
                }
            }
            
            // Shutdown executor with proper timeout
            if (executor != null && !executor.isShutdown()) {
                executor.shutdown();
                try {
                    if (!executor.awaitTermination(15, TimeUnit.SECONDS)) {
                        LOGGER.warn("Executor shutdown timeout, forcing termination");
                        List<Runnable> pending = executor.shutdownNow();
                        LOGGER.info("Cancelled {} pending tasks", pending.size());
                        
                        if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                            LOGGER.error("Executor failed to terminate");
                        }
                    }
                } catch (InterruptedException e) {
                    LOGGER.warn("Interrupted during shutdown");
                    executor.shutdownNow();
                    Thread.currentThread().interrupt();
                }
            }
            
            initialized = false;
            LOGGER.info("WebView manager cleanup completed");
        }
    }
    
    public static PlatformType getPlatform() { return platform; }
    public static boolean isInitialized() { return initialized; }
}

// WebView Provider Interface
public interface WebViewProvider {
    void initialize() throws Exception;
    MEWVFBrowser createBrowser(String id, int width, int height) throws Exception;
    void cleanup();
    String getProviderName();
    String getWebViewVersion();
}

// Android WebView Provider (Latest WebView 120.x)
public class AndroidWebViewProvider implements WebViewProvider {
    private Context context;
    private Handler mainHandler;
    private static final Logger LOGGER = LogUtils.getLogger();
    
    @Override
    public void initialize() throws Exception {
        context = getAndroidContext();
        mainHandler = new Handler(Looper.getMainL